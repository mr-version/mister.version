<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<!-- This file is imported during outer builds (multi-targeting scenarios) -->
	<!-- It runs when $(IsCrossTargetingBuild) == true and $(TargetFramework) is empty -->

	<!-- DIAGNOSTIC: Log that this file is being imported -->
	<Target Name="_DiagnosticOuterBuildImported" BeforeTargets="BeforeBuild;Build;Pack" Condition="'$(MonoRepoExtraDebug)' == 'true'">
		<Message Importance="High" Text="================================================================" />
		<Message Importance="High" Text="[DIAGNOSTIC] buildMultiTargeting/Mister.Version.targets IMPORTED" />
		<Message Importance="High" Text="[DIAGNOSTIC] Project: $(MSBuildProjectName)" />
		<Message Importance="High" Text="[DIAGNOSTIC] IsCrossTargetingBuild: $(IsCrossTargetingBuild)" />
		<Message Importance="High" Text="[DIAGNOSTIC] TargetFramework: $(TargetFramework)" />
		<Message Importance="High" Text="[DIAGNOSTIC] TargetFrameworks: $(TargetFrameworks)" />
		<Message Importance="High" Text="[DIAGNOSTIC] IsPackable: $(IsPackable)" />
		<Message Importance="High" Text="[DIAGNOSTIC] AppSettingStronglyTyped_TFM: $(AppSettingStronglyTyped_TFM)" />
		<Message Importance="High" Text="================================================================" />
	</Target>

	<!-- During outer build, set a default TFM for loading the task assembly -->
	<PropertyGroup>
		<AppSettingStronglyTyped_TFM Condition="'$(AppSettingStronglyTyped_TFM)' == ''">net8.0</AppSettingStronglyTyped_TFM>
	</PropertyGroup>

	<!-- Include the versioning task - use same path as regular build targets -->
	<UsingTask TaskName="Mister.Version.MonoRepoVersionTask" AssemblyFile="$(MSBuildThisFileDirectory)../tasks/$(AppSettingStronglyTyped_TFM)/Mister.Version.dll" />

	<!-- DIAGNOSTIC: Log UsingTask path -->
	<Target Name="_DiagnosticTaskPath" BeforeTargets="BeforeBuild;Build;Pack" Condition="'$(MonoRepoExtraDebug)' == 'true'">
		<Message Importance="High" Text="[DIAGNOSTIC-TASK] Task assembly path: $(MSBuildThisFileDirectory)../tasks/$(AppSettingStronglyTyped_TFM)/Mister.Version.dll" />
	</Target>

	<!-- CRITICAL: This target runs during outer build before nuspec generation -->
	<!-- It calculates the version and sets PackageVersion property for Pack -->
	<Target Name="_MonoRepoOuterBuildVersioning"
	        Condition="'$(IsPackable)' == 'true'">
		<Message Importance="High" Text="[DIAGNOSTIC] _MonoRepoOuterBuildVersioning target EXECUTING" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
		<Message Importance="High" Text="[DIAGNOSTIC] IsPackable condition: $(IsPackable)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
		<Message Importance="High" Text="[OuterBuild] Starting version calculation for $(MSBuildProjectName)" Condition="'$(MonoRepoDebug)' == 'true'" />

		<!-- Automatically detect dependencies based on ProjectReference -->
		<ItemGroup>
			<_MonoRepoDependencies Include="@(ProjectReference)" />
		</ItemGroup>

		<!-- Run the versioning task to calculate version during outer build -->
		<MonoRepoVersionTask
			ProjectPath="$(MSBuildProjectFullPath)"
			RepoRoot="$(MonoRepoRoot)"
			TagPrefix="$(MonoRepoTagPrefix)"
			UpdateProjectFile="$(MonoRepoUpdateProjectFile)"
			ForceVersion="$(ForceVersion)"
			Debug="$(MonoRepoDebug)"
			ExtraDebug="$(MonoRepoExtraDebug)"
			SkipTestProjects="$(MonoRepoSkipTestProjects)"
			SkipNonPackableProjects="$(MonoRepoSkipNonPackableProjects)"
			IsTestProject="$(IsTestProject)"
			IsPackable="$(IsPackable)"
			PrereleaseType="$(MonoRepoPrereleaseType)"
			ConfigFile="$(MonoRepoConfigFile)"
			ConventionalCommitsEnabled="$(MonoRepoConventionalCommitsEnabled)"
			MajorPatterns="$(MonoRepoMajorPatterns)"
			MinorPatterns="$(MonoRepoMinorPatterns)"
			PatchPatterns="$(MonoRepoPatchPatterns)"
			IgnorePatterns="$(MonoRepoIgnorePatterns)"
			ChangeDetectionEnabled="$(MonoRepoChangeDetectionEnabled)"
			IgnoreFilePatterns="$(MonoRepoIgnoreFilePatterns)"
			MajorFilePatterns="$(MonoRepoMajorFilePatterns)"
			MinorFilePatterns="$(MonoRepoMinorFilePatterns)"
			PatchFilePatterns="$(MonoRepoPatchFilePatterns)"
			SourceOnlyMode="$(MonoRepoSourceOnlyMode)"
			GenerateChangelog="$(MonoRepoGenerateChangelog)"
			ChangelogFormat="$(MonoRepoChangelogFormat)"
			ChangelogOutputPath="$(MonoRepoChangelogOutputPath)"
			ChangelogRepositoryUrl="$(MonoRepoChangelogRepositoryUrl)"
			ChangelogIncludeAuthors="$(MonoRepoChangelogIncludeAuthors)"
			Dependencies="@(_MonoRepoDependencies)">
			<Output TaskParameter="Version" PropertyName="FullVersion" />
			<Output TaskParameter="VersionChanged" PropertyName="VersionChanged" />
			<Output TaskParameter="DiscoveredRepoRoot" PropertyName="DiscoveredRepoRoot" />
		</MonoRepoVersionTask>

		<!-- Calculate different version formats -->
		<PropertyGroup>
			<IsPrerelease Condition="$(FullVersion.Contains('-'))">true</IsPrerelease>
			<IsPrerelease Condition="!$(FullVersion.Contains('-'))">false</IsPrerelease>
			<MainVersion Condition="'$(IsPrerelease)' == 'true'">$(FullVersion.Split('-')[0])</MainVersion>
			<MainVersion Condition="'$(IsPrerelease)' == 'false'">$(FullVersion)</MainVersion>
		</PropertyGroup>

		<!-- Set all version properties for Pack to use -->
		<PropertyGroup>
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
			<AssemblyVersion>$(MainVersion)</AssemblyVersion>
			<FileVersion>$(MainVersion)</FileVersion>
			<InformationalVersion>$(FullVersion)</InformationalVersion>
		</PropertyGroup>

		<!-- Write version to a TFM-agnostic file so it's available when other projects query this one -->
		<!-- This ensures dependency version resolution works correctly -->
		<PropertyGroup>
			<_OuterBuildVersionPropsPath>$(MSBuildProjectDirectory)\obj\$(Configuration)\$(MSBuildProjectName).outerbuild.version.props</_OuterBuildVersionPropsPath>
		</PropertyGroup>

		<!-- Get current git HEAD SHA for cache validation -->
		<Exec Command="git rev-parse HEAD"
		      WorkingDirectory="$(DiscoveredRepoRoot)"
		      ConsoleToMSBuild="true"
		      IgnoreExitCode="true"
		      ContinueOnError="true"
		      Condition="'$(DiscoveredRepoRoot)' != ''">
			<Output TaskParameter="ConsoleOutput" PropertyName="_GitHeadSha" />
		</Exec>

		<ItemGroup>
			<_VersionPropsLines Include="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;" />
			<_VersionPropsLines Include="&lt;Project&gt;" />
			<_VersionPropsLines Include="  &lt;PropertyGroup&gt;" />
			<_VersionPropsLines Include="    &lt;!-- Generated by Mister.Version during outer build --&gt;" />
			<_VersionPropsLines Include="    &lt;!-- GitHeadSha: $(_GitHeadSha) --&gt;" />
			<_VersionPropsLines Include="    &lt;MisterVersion_CachedGitHeadSha&gt;$(_GitHeadSha)&lt;/MisterVersion_CachedGitHeadSha&gt;" />
			<_VersionPropsLines Include="    &lt;PackageVersion&gt;$(FullVersion)&lt;/PackageVersion&gt;" />
			<_VersionPropsLines Include="    &lt;Version&gt;$(FullVersion)&lt;/Version&gt;" />
			<_VersionPropsLines Include="    &lt;AssemblyVersion&gt;$(MainVersion)&lt;/AssemblyVersion&gt;" />
			<_VersionPropsLines Include="    &lt;FileVersion&gt;$(MainVersion)&lt;/FileVersion&gt;" />
			<_VersionPropsLines Include="    &lt;InformationalVersion&gt;$(FullVersion)&lt;/InformationalVersion&gt;" />
			<_VersionPropsLines Include="  &lt;/PropertyGroup&gt;" />
			<_VersionPropsLines Include="&lt;/Project&gt;" />
		</ItemGroup>

		<WriteLinesToFile File="$(_OuterBuildVersionPropsPath)"
		                  Lines="@(_VersionPropsLines)"
		                  Overwrite="true" />

		<Message Importance="High" Text="[OuterBuild] Calculated version: $(FullVersion)" Condition="'$(MonoRepoDebug)' == 'true'" />
		<Message Importance="High" Text="[OuterBuild] Set PackageVersion=$(PackageVersion) for NuGet Pack" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
		<Message Importance="High" Text="[OuterBuild] Wrote version cache to: $(_OuterBuildVersionPropsPath)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
		<Message Importance="High" Text="[OuterBuild] Cache git HEAD SHA: $(_GitHeadSha)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
	</Target>

	<!-- DIAGNOSTIC: Show what dependencies NuGet Pack will use -->
	<Target Name="_DiagnosticShowNuGetDependencies"
	        AfterTargets="_WalkEachTargetPerFramework"
	        BeforeTargets="GenerateNuspec"
	        Condition="'$(IsPackable)' == 'true' and '$(MonoRepoExtraDebug)' == 'true'">
		<Message Importance="High" Text="================================================================" />
		<Message Importance="High" Text="[NuGetDeps] DIAGNOSTIC - Dependencies that will be in nuspec:" />
		<Message Importance="High" Text="[NuGetDeps] Project: $(MSBuildProjectName)" />
		<Message Importance="High" Text="[NuGetDeps] PackageVersion: $(PackageVersion)" />
		<Message Importance="High" Text="[NuGetDeps] Version: $(Version)" />
		<Message Importance="High" Text="[NuGetDeps] " />
		<Message Importance="High" Text="[NuGetDeps] ProjectReferences (@(ProjectReference->Count()) items):" />
		<Message Importance="High" Text="[NuGetDeps]   %(ProjectReference.Identity)" />
		<Message Importance="High" Text="[NuGetDeps]     - PackageVersion metadata: %(ProjectReference.PackageVersion)" />
		<Message Importance="High" Text="[NuGetDeps]     - Version metadata: %(ProjectReference.Version)" />
		<Message Importance="High" Text="[NuGetDeps] " />
		<Message Importance="High" Text="[NuGetDeps] _ProjectReferencesFromRAR items (@(_ProjectReferencesFromRAR->Count()) items):" />
		<Message Importance="High" Text="[NuGetDeps]   %(_ProjectReferencesFromRAR.Identity) - Version=%(_ProjectReferencesFromRAR.Version), PackageVersion=%(_ProjectReferencesFromRAR.PackageVersion)" />
		<Message Importance="High" Text="[NuGetDeps] " />
		<Message Importance="High" Text="[NuGetDeps] PackageDependencies items (@(PackageDependencies->Count()) items):" />
		<Message Importance="High" Text="[NuGetDeps]   %(PackageDependencies.Identity) - Version=%(PackageDependencies.Version)" />
		<Message Importance="High" Text="================================================================" />
	</Target>

	<!-- Helper target that calculates version for dependency resolution -->
	<!-- This runs without IsPackable condition so dependencies can get our version -->
	<!-- OPTIMIZATION: Imports cached version if available and valid -->
	<Target Name="_MonoRepoCalculateVersionForDependencyResolution"
	        Condition="'$(FullVersion)' == ''">
		<Message Importance="High" Text="================================================================" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
		<Message Importance="High" Text="[Cache] Dependency resolution for $(MSBuildProjectName)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />

		<!-- STEP 1: Check for cached version props file -->
		<PropertyGroup>
			<_CachedVersionPropsPath>$(MSBuildProjectDirectory)\obj\$(Configuration)\$(MSBuildProjectName).outerbuild.version.props</_CachedVersionPropsPath>
			<_CacheFileExists>false</_CacheFileExists>
			<_CacheFileExists Condition="Exists('$(_CachedVersionPropsPath)')">true</_CacheFileExists>
		</PropertyGroup>

		<Message Importance="High" Text="[Cache] Checking for cache file: $(_CachedVersionPropsPath)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
		<Message Importance="High" Text="[Cache] Cache file exists: $(_CacheFileExists)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />

		<!-- STEP 2: Get current git HEAD SHA for validation -->
		<Exec Command="git rev-parse HEAD"
		      WorkingDirectory="$(MSBuildProjectDirectory)"
		      ConsoleToMSBuild="true"
		      IgnoreExitCode="true"
		      ContinueOnError="true"
		      Condition="'$(_CacheFileExists)' == 'true'">
			<Output TaskParameter="ConsoleOutput" PropertyName="_CurrentGitHeadSha" />
			<Output TaskParameter="ExitCode" PropertyName="_GitExitCode" />
		</Exec>

		<PropertyGroup Condition="'$(_CacheFileExists)' == 'true'">
			<_CurrentGitHeadSha Condition="'$(_GitExitCode)' != '0'"></_CurrentGitHeadSha>
			<!-- Trim whitespace from git output -->
			<_CurrentGitHeadSha>$(_CurrentGitHeadSha.Trim())</_CurrentGitHeadSha>
		</PropertyGroup>

		<Message Importance="High" Text="[Cache] Current git HEAD: $(_CurrentGitHeadSha)" Condition="'$(MonoRepoExtraDebug)' == 'true' and '$(_CurrentGitHeadSha)' != ''" />

		<!-- STEP 3: Try to import cached version (will set PackageVersion and MisterVersion_CachedGitHeadSha) -->
		<Import Project="$(_CachedVersionPropsPath)"
		        Condition="'$(_CacheFileExists)' == 'true'" />

		<!-- STEP 4: Validate cache - check if git HEAD matches -->
		<PropertyGroup Condition="'$(_CacheFileExists)' == 'true'">
			<_CacheIsValid>false</_CacheIsValid>
			<!-- Cache is valid if we have a cached git HEAD and it matches current HEAD -->
			<_CacheIsValid Condition="'$(MisterVersion_CachedGitHeadSha)' != '' and '$(MisterVersion_CachedGitHeadSha)' == '$(_CurrentGitHeadSha)'">true</_CacheIsValid>
		</PropertyGroup>

		<Message Importance="High" Text="[Cache] Cached git HEAD: $(MisterVersion_CachedGitHeadSha)" Condition="'$(MonoRepoExtraDebug)' == 'true' and '$(MisterVersion_CachedGitHeadSha)' != ''" />
		<Message Importance="High" Text="[Cache] Cache is valid: $(_CacheIsValid)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />

		<!-- STEP 5: Determine if we need to calculate version -->
		<PropertyGroup>
			<_NeedVersionCalculation>true</_NeedVersionCalculation>
			<!-- Skip calculation if we have a valid cache -->
			<_NeedVersionCalculation Condition="'$(_CacheIsValid)' == 'true' and '$(PackageVersion)' != ''">false</_NeedVersionCalculation>
		</PropertyGroup>

		<!-- Report cache hit/miss -->
		<Message Importance="High" Text="[Cache] ✓ CACHE HIT - Using cached version $(PackageVersion) for $(MSBuildProjectName)"
		         Condition="'$(_NeedVersionCalculation)' == 'false' and '$(MonoRepoDebug)' == 'true'" />
		<Message Importance="High" Text="[Cache] ✗ CACHE MISS - Calculating version for $(MSBuildProjectName)"
		         Condition="'$(_NeedVersionCalculation)' == 'true' and '$(MonoRepoDebug)' == 'true'" />
		<Message Importance="High" Text="[Cache] Reason: Cache file not found"
		         Condition="'$(_NeedVersionCalculation)' == 'true' and '$(_CacheFileExists)' == 'false' and '$(MonoRepoExtraDebug)' == 'true'" />
		<Message Importance="High" Text="[Cache] Reason: Git HEAD changed (cached: $(MisterVersion_CachedGitHeadSha), current: $(_CurrentGitHeadSha))"
		         Condition="'$(_NeedVersionCalculation)' == 'true' and '$(_CacheFileExists)' == 'true' and '$(_CacheIsValid)' == 'false' and '$(MonoRepoExtraDebug)' == 'true'" />

		<!-- STEP 6: Calculate version only if needed -->
		<ItemGroup Condition="'$(_NeedVersionCalculation)' == 'true'">
			<_MonoRepoDependencies Include="@(ProjectReference)" />
		</ItemGroup>

		<MonoRepoVersionTask Condition="'$(_NeedVersionCalculation)' == 'true'"
			ProjectPath="$(MSBuildProjectFullPath)"
			RepoRoot="$(MonoRepoRoot)"
			TagPrefix="$(MonoRepoTagPrefix)"
			UpdateProjectFile="$(MonoRepoUpdateProjectFile)"
			ForceVersion="$(ForceVersion)"
			Debug="$(MonoRepoDebug)"
			ExtraDebug="$(MonoRepoExtraDebug)"
			SkipTestProjects="$(MonoRepoSkipTestProjects)"
			SkipNonPackableProjects="$(MonoRepoSkipNonPackableProjects)"
			IsTestProject="$(IsTestProject)"
			IsPackable="$(IsPackable)"
			PrereleaseType="$(MonoRepoPrereleaseType)"
			ConfigFile="$(MonoRepoConfigFile)"
			ConventionalCommitsEnabled="$(MonoRepoConventionalCommitsEnabled)"
			MajorPatterns="$(MonoRepoMajorPatterns)"
			MinorPatterns="$(MonoRepoMinorPatterns)"
			PatchPatterns="$(MonoRepoPatchPatterns)"
			IgnorePatterns="$(MonoRepoIgnorePatterns)"
			ChangeDetectionEnabled="$(MonoRepoChangeDetectionEnabled)"
			IgnoreFilePatterns="$(MonoRepoIgnoreFilePatterns)"
			MajorFilePatterns="$(MonoRepoMajorFilePatterns)"
			MinorFilePatterns="$(MonoRepoMinorFilePatterns)"
			PatchFilePatterns="$(MonoRepoPatchFilePatterns)"
			SourceOnlyMode="$(MonoRepoSourceOnlyMode)"
			GenerateChangelog="$(MonoRepoGenerateChangelog)"
			ChangelogFormat="$(MonoRepoChangelogFormat)"
			ChangelogOutputPath="$(MonoRepoChangelogOutputPath)"
			ChangelogRepositoryUrl="$(MonoRepoChangelogRepositoryUrl)"
			ChangelogIncludeAuthors="$(MonoRepoChangelogIncludeAuthors)"
			Dependencies="@(_MonoRepoDependencies)">
			<Output TaskParameter="Version" PropertyName="FullVersion" />
			<Output TaskParameter="VersionChanged" PropertyName="VersionChanged" />
			<Output TaskParameter="DiscoveredRepoRoot" PropertyName="DiscoveredRepoRoot" />
		</MonoRepoVersionTask>

		<!-- STEP 7: Set FullVersion from cached PackageVersion if we used cache -->
		<PropertyGroup Condition="'$(_NeedVersionCalculation)' == 'false'">
			<FullVersion>$(PackageVersion)</FullVersion>
			<Version>$(PackageVersion)</Version>
		</PropertyGroup>

		<!-- Calculate different version formats (only needed if we just calculated) -->
		<PropertyGroup Condition="'$(_NeedVersionCalculation)' == 'true'">
			<IsPrerelease Condition="$(FullVersion.Contains('-'))">true</IsPrerelease>
			<IsPrerelease Condition="!$(FullVersion.Contains('-'))">false</IsPrerelease>
			<MainVersion Condition="'$(IsPrerelease)' == 'true'">$(FullVersion.Split('-')[0])</MainVersion>
			<MainVersion Condition="'$(IsPrerelease)' == 'false'">$(FullVersion)</MainVersion>
		</PropertyGroup>

		<!-- Set all version properties (if not already set from cache) -->
		<PropertyGroup Condition="'$(_NeedVersionCalculation)' == 'true'">
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
			<AssemblyVersion>$(MainVersion)</AssemblyVersion>
			<FileVersion>$(MainVersion)</FileVersion>
			<InformationalVersion>$(FullVersion)</InformationalVersion>
		</PropertyGroup>

		<!-- Also calculate MainVersion from cached data if we used cache -->
		<PropertyGroup Condition="'$(_NeedVersionCalculation)' == 'false'">
			<IsPrerelease Condition="$(FullVersion.Contains('-'))">true</IsPrerelease>
			<IsPrerelease Condition="!$(FullVersion.Contains('-'))">false</IsPrerelease>
			<MainVersion Condition="'$(IsPrerelease)' == 'true'">$(FullVersion.Split('-')[0])</MainVersion>
			<MainVersion Condition="'$(IsPrerelease)' == 'false'">$(FullVersion)</MainVersion>
			<!-- Set other version properties if not already set -->
			<AssemblyVersion Condition="'$(AssemblyVersion)' == ''">$(MainVersion)</AssemblyVersion>
			<FileVersion Condition="'$(FileVersion)' == ''">$(MainVersion)</FileVersion>
			<InformationalVersion Condition="'$(InformationalVersion)' == ''">$(FullVersion)</InformationalVersion>
		</PropertyGroup>

		<Message Importance="High" Text="[Cache] Final version: $(FullVersion)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
		<Message Importance="High" Text="================================================================" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
	</Target>

	<!-- CRITICAL: This target is called by NuGet Pack's _GetProjectReferenceVersions -->
	<!-- It MUST return an item with ProjectVersion metadata for NuGet dependency resolution -->
	<Target Name="_GetProjectVersion"
	        DependsOnTargets="_MonoRepoCalculateVersionForDependencyResolution"
	        Returns="@(_ProjectPathWithVersion)">

		<Message Importance="High" Text="[_GetProjectVersion] CALLED by NuGet Pack for $(MSBuildProjectName)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
		<Message Importance="High" Text="[_GetProjectVersion] PackageVersion: $(PackageVersion)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
		<Message Importance="High" Text="[_GetProjectVersion] FullVersion: $(FullVersion)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />

		<PropertyGroup>
			<!-- Determine version to return -->
			<_VersionForPack Condition="'$(FullVersion)' != ''">$(FullVersion)</_VersionForPack>
			<_VersionForPack Condition="'$(_VersionForPack)' == '' and '$(PackageVersion)' != ''">$(PackageVersion)</_VersionForPack>
			<_VersionForPack Condition="'$(_VersionForPack)' == '' and '$(Version)' != ''">$(Version)</_VersionForPack>
			<_VersionForPack Condition="'$(_VersionForPack)' == ''">1.0.0</_VersionForPack>
		</PropertyGroup>

		<ItemGroup>
			<_ProjectPathWithVersion Include="$(MSBuildProjectFullPath)">
				<ProjectVersion>$(_VersionForPack)</ProjectVersion>
			</_ProjectPathWithVersion>
		</ItemGroup>

		<Message Importance="High" Text="[_GetProjectVersion] RETURNING version: $(_VersionForPack)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
	</Target>

	<!--
	EXPERIMENTAL TARGETS - NOT NEEDED
	These approaches were tried but didn't work. Keeping commented for reference.
	The actual fix uses GetPackageVersionDependsOn + _GetProjectVersion.

	<Target Name="_MonoRepoGetPackageVersion">
		Helper target for experimental approaches
	</Target>

	<UsingTask TaskName="UpdateProjectReferenceVersions">
		Inline task for experimental dependency injection
	</UsingTask>

	<Target Name="_GetProjectReferenceVersions">
		Attempted override of NuGet's target - doesn't work because NuGet's targets
		are imported after ours, so their definition takes precedence
	</Target>

	<Target Name="_MonoRepoInjectDependencyVersions">
		Experimental backup approach to inject versions directly into metadata
	</Target>
	-->
</Project>
