<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<!-- Include the versioning task -->
	<UsingTask TaskName="Mister.Version.MonoRepoVersionTask" AssemblyFile="$(MSBuildThisFileDirectory)../tasks/$(AppSettingStronglyTyped_TFM)/Mister.Version.dll" />

	<!-- CRITICAL: Ensure test projects have versions set immediately to prevent GenerateDepsFile errors -->
	<PropertyGroup Condition="'$(IsTestProject)' == 'true'">
		<AssemblyVersion Condition="'$(AssemblyVersion)' == ''">1.0.0.0</AssemblyVersion>
		<FileVersion Condition="'$(FileVersion)' == ''">1.0.0.0</FileVersion>
		<Version Condition="'$(Version)' == ''">1.0.0</Version>
		<PackageVersion Condition="'$(PackageVersion)' == ''">1.0.0</PackageVersion>
		<InformationalVersion Condition="'$(InformationalVersion)' == ''">1.0.0</InformationalVersion>
		<MonoRepoVersioningEnabled>false</MonoRepoVersioningEnabled>
	</PropertyGroup>

	<!-- Initial target to set version properties early in MSBuild evaluation -->
	<Target Name="_MonoRepoSetVersion"
        Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsTestProject)' != 'true'">
		<!-- Automatically detect dependencies based on ProjectReference -->
		<ItemGroup>
			<_MonoRepoDependencies Include="@(ProjectReference)" />
		</ItemGroup>

		<!-- Run the versioning task to get the version -->
		<MonoRepoVersionTask ProjectPath="$(MSBuildProjectFullPath)" RepoRoot="$(MonoRepoRoot)" TagPrefix="$(MonoRepoTagPrefix)" UpdateProjectFile="$(MonoRepoUpdateProjectFile)" ForceVersion="$(ForceVersion)" Debug="$(MonoRepoDebug)" ExtraDebug="$(MonoRepoExtraDebug)" SkipTestProjects="$(MonoRepoSkipTestProjects)" SkipNonPackableProjects="$(MonoRepoSkipNonPackableProjects)" IsTestProject="$(IsTestProject)" IsPackable="$(IsPackable)" PrereleaseType="$(MonoRepoPrereleaseType)" ConfigFile="$(MonoRepoConfigFile)" ConventionalCommitsEnabled="$(MonoRepoConventionalCommitsEnabled)" MajorPatterns="$(MonoRepoMajorPatterns)" MinorPatterns="$(MonoRepoMinorPatterns)" PatchPatterns="$(MonoRepoPatchPatterns)" IgnorePatterns="$(MonoRepoIgnorePatterns)" ChangeDetectionEnabled="$(MonoRepoChangeDetectionEnabled)" IgnoreFilePatterns="$(MonoRepoIgnoreFilePatterns)" MajorFilePatterns="$(MonoRepoMajorFilePatterns)" MinorFilePatterns="$(MonoRepoMinorFilePatterns)" PatchFilePatterns="$(MonoRepoPatchFilePatterns)" SourceOnlyMode="$(MonoRepoSourceOnlyMode)" GenerateChangelog="$(MonoRepoGenerateChangelog)" ChangelogFormat="$(MonoRepoChangelogFormat)" ChangelogOutputPath="$(MonoRepoChangelogOutputPath)" ChangelogRepositoryUrl="$(MonoRepoChangelogRepositoryUrl)" ChangelogIncludeAuthors="$(MonoRepoChangelogIncludeAuthors)" ShallowCloneSupport="$(MonoRepoShallowCloneSupport)" ShallowCloneFallbackVersion="$(MonoRepoShallowCloneFallbackVersion)" SubmoduleSupport="$(MonoRepoSubmoduleSupport)" CustomTagPatterns="$(MonoRepoCustomTagPatterns)" BranchBasedVersioning="$(MonoRepoBranchBasedVersioning)" BranchVersioningRules="$(MonoRepoBranchVersioningRules)" IncludeBranchInMetadata="$(MonoRepoIncludeBranchInMetadata)" ValidateTagAncestry="$(MonoRepoValidateTagAncestry)" FetchDepth="$(MonoRepoFetchDepth)" Dependencies="@(_MonoRepoDependencies)">
			<Output TaskParameter="Version" PropertyName="FullVersion" />
			<Output TaskParameter="VersionChanged" PropertyName="VersionChanged" />
			<Output TaskParameter="DiscoveredRepoRoot" PropertyName="DiscoveredRepoRoot" />
		</MonoRepoVersionTask>

		<!-- Calculate different version formats -->
		<PropertyGroup>
			<IsPrerelease Condition="$(FullVersion.Contains('-'))">true</IsPrerelease>
			<IsPrerelease Condition="!$(FullVersion.Contains('-'))">false</IsPrerelease>
			<MainVersion Condition="'$(IsPrerelease)' == 'true'">$(FullVersion.Split('-')[0])</MainVersion>
			<MainVersion Condition="'$(IsPrerelease)' == 'false'">$(FullVersion)</MainVersion>
		</PropertyGroup>

		<!-- Write version to TFM-specific location for current build -->
		<PropertyGroup>
			<MrVersionAssemblyRefFile>$(IntermediateOutputPath)$(MSBuildProjectName).version.props</MrVersionAssemblyRefFile>
		</PropertyGroup>

		<!-- Ensure obj directory exists -->
		<MakeDir Directories="$(IntermediateOutputPath)" />

		<!-- Write version properties to TFM-specific file -->
		<WriteLinesToFile File="$(MrVersionAssemblyRefFile)"
            Lines="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;;&lt;Project&gt;;&lt;PropertyGroup&gt;;&lt;PackageVersion&gt;$(FullVersion)&lt;/PackageVersion&gt;;&lt;Version&gt;$(FullVersion)&lt;/Version&gt;;&lt;AssemblyVersion&gt;$(MainVersion)&lt;/AssemblyVersion&gt;;&lt;FileVersion&gt;$(MainVersion)&lt;/FileVersion&gt;;&lt;InformationalVersion&gt;$(FullVersion)&lt;/InformationalVersion&gt;;&lt;/PropertyGroup&gt;;&lt;/Project&gt;"
            Overwrite="true" />

		<!-- ALSO write to TFM-agnostic location for cross-project queries -->
		<!-- Only write from first TFM to avoid parallel file access conflicts -->
		<PropertyGroup>
			<_SharedVersionPropsPath>$(MSBuildProjectDirectory)\obj\$(Configuration)\$(MSBuildProjectName).outerbuild.version.props</_SharedVersionPropsPath>
			<_ShouldWriteSharedVersion>false</_ShouldWriteSharedVersion>
			<!-- Write if file doesn't exist OR if this is the first TFM in TargetFrameworks -->
			<_ShouldWriteSharedVersion Condition="!Exists('$(_SharedVersionPropsPath)')">true</_ShouldWriteSharedVersion>
			<!-- Only write from one TFM to prevent conflicts - use the first one alphabetically -->
			<_FirstTargetFramework>$(TargetFrameworks.Split(';')[0])</_FirstTargetFramework>
			<_ShouldWriteSharedVersion Condition="'$(TargetFramework)' == '$(_FirstTargetFramework)'">true</_ShouldWriteSharedVersion>
			<!-- Always write if not multi-targeting -->
			<_ShouldWriteSharedVersion Condition="'$(TargetFrameworks)' == ''">true</_ShouldWriteSharedVersion>
		</PropertyGroup>

		<MakeDir Directories="$(MSBuildProjectDirectory)\obj\$(Configuration)" Condition="'$(_ShouldWriteSharedVersion)' == 'true'" />

		<ItemGroup Condition="'$(_ShouldWriteSharedVersion)' == 'true'">
			<_SharedVersionLines Include="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;" />
			<_SharedVersionLines Include="&lt;Project&gt;" />
			<_SharedVersionLines Include="  &lt;PropertyGroup&gt;" />
			<_SharedVersionLines Include="    &lt;!-- Generated by Mister.Version for cross-project version queries --&gt;" />
			<_SharedVersionLines Include="    &lt;PackageVersion&gt;$(FullVersion)&lt;/PackageVersion&gt;" />
			<_SharedVersionLines Include="    &lt;Version&gt;$(FullVersion)&lt;/Version&gt;" />
			<_SharedVersionLines Include="    &lt;AssemblyVersion&gt;$(MainVersion)&lt;/AssemblyVersion&gt;" />
			<_SharedVersionLines Include="    &lt;FileVersion&gt;$(MainVersion)&lt;/FileVersion&gt;" />
			<_SharedVersionLines Include="    &lt;InformationalVersion&gt;$(FullVersion)&lt;/InformationalVersion&gt;" />
			<_SharedVersionLines Include="  &lt;/PropertyGroup&gt;" />
			<_SharedVersionLines Include="&lt;/Project&gt;" />
		</ItemGroup>

		<!-- Write with error handling for concurrent access -->
		<WriteLinesToFile File="$(_SharedVersionPropsPath)"
		                  Lines="@(_SharedVersionLines)"
		                  Overwrite="true"
		                  WriteOnlyWhenDifferent="true"
		                  ContinueOnError="true"
		                  Condition="'$(_ShouldWriteSharedVersion)' == 'true'" />

		<Message Text="[MrVersion] Written version properties to: $(MrVersionAssemblyRefFile)" Importance="High" Condition="'$(MonoRepoDebug)'=='true'" />
		<Message Text="[MrVersion] Written shared version to: $(_SharedVersionPropsPath)" Importance="High" Condition="'$(MonoRepoDebug)'=='true'" />

		<!-- Force immediate property update using CreateProperty tasks -->
		<CreateProperty Value="$(FullVersion)" Condition="'$(IsPackable)' == 'true'">
			<Output TaskParameter="ValueSetByTask" PropertyName="PackageVersion" />
		</CreateProperty>
		<CreateProperty Value="$(FullVersion)" Condition="'$(IsPackable)' == 'true'">
			<Output TaskParameter="ValueSetByTask" PropertyName="Version" />
		</CreateProperty>
		<PropertyGroup>
			<IsPrerelease Condition="$(FullVersion.Contains('-'))">true</IsPrerelease>
			<IsPrerelease Condition="!$(FullVersion.Contains('-'))">false</IsPrerelease>
			<MainVersion Condition="'$(IsPrerelease)' == 'true'">$(FullVersion.Split('-')[0])</MainVersion>
			<MainVersion Condition="'$(IsPrerelease)' == 'false'">$(FullVersion)</MainVersion>
		</PropertyGroup>

		<!-- Disable automatic assembly info generation -->
		<CreateProperty Value="false">
			<Output TaskParameter="ValueSetByTask" PropertyName="GenerateAssemblyVersionAttribute" />
		</CreateProperty>
		<CreateProperty Value="false">
			<Output TaskParameter="ValueSetByTask" PropertyName="GenerateAssemblyFileVersionAttribute" />
		</CreateProperty>
		<CreateProperty Value="false">
			<Output TaskParameter="ValueSetByTask" PropertyName="GenerateAssemblyInformationalVersionAttribute" />
		</CreateProperty>

		<ItemGroup>
			<ProjectVersionInfo Include="$(MSBuildProjectName)">
				<FullVersion>$(FullVersion)</FullVersion>
				<MainVersion>$(MainVersion)</MainVersion>
				<IsPrerelease>$(IsPrerelease)</IsPrerelease>
			</ProjectVersionInfo>
		</ItemGroup>

		<PropertyGroup>
			<!-- Get the version for the specific project -->
			<RetrievedVersion>@(ProjectVersionInfo->WithMetadataValue('Identity', '$(MSBuildProjectName)')->Metadata('FullVersion'))</RetrievedVersion>
			<IsPrerelease Condition="$(FullVersion.Contains('-'))">true</IsPrerelease>
			<IsPrerelease Condition="!$(FullVersion.Contains('-'))">false</IsPrerelease>
			<MainVersion Condition="'$(IsPrerelease)' == 'true'">$(FullVersion.Split('-')[0])</MainVersion>
			<MainVersion Condition="'$(IsPrerelease)' == 'false'">$(FullVersion)</MainVersion>

			<!-- Set Version Properties with immediate evaluation - override with calculated version when available -->
			<Version Condition="'$(FullVersion)' != ''">$(FullVersion)</Version>
			<PackageVersion Condition="'$(FullVersion)' != ''">$(FullVersion)</PackageVersion>
			<AssemblyVersion Condition="'$(FullVersion)' != ''">$(MainVersion)</AssemblyVersion>
			<FileVersion Condition="'$(FullVersion)' != ''">$(MainVersion)</FileVersion>
			<InformationalVersion Condition="'$(FullVersion)' != ''">$(FullVersion)</InformationalVersion>

			<!-- Ensure properties are available for NuGet property evaluation -->
			<_MrVersionCalculated>$(FullVersion)</_MrVersionCalculated>

			<!-- Disable automatic assembly info generation to avoid duplicates -->
			<GenerateAssemblyInfo>true</GenerateAssemblyInfo>
			<GenerateAssemblyVersionAttribute>false</GenerateAssemblyVersionAttribute>
			<GenerateAssemblyFileVersionAttribute>false</GenerateAssemblyFileVersionAttribute>
			<GenerateAssemblyInformationalVersionAttribute>false</GenerateAssemblyInformationalVersionAttribute>
		</PropertyGroup>

        <Message Text="MonoRepo Versioning: Set version $(FullVersion) for $(MSBuildProjectName)" Importance="High" Condition="'$(MonoRepoDebug)'=='true'"/>
	</Target>

	<!-- Generate AssemblyInfo file during normal build process - run VERY early -->
	<Target Name="_MonoRepoCalculateVersion"
        DependsOnTargets="_MonoRepoSetVersion"
        BeforeTargets="GetAssemblyAttributes;GenerateAssemblyInfo;CoreGenerateAssemblyInfo;PrepareForBuild"
        Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsTestProject)' != 'true'">
		<!-- Use the version from the generated props file (which should be imported by now) -->
		<PropertyGroup>
			<!-- Check if this is a pre-release version (has a dash) -->
			<IsPrerelease Condition="$(Version.Contains('-'))">true</IsPrerelease>
			<IsPrerelease Condition="!$(Version.Contains('-'))">false</IsPrerelease>

			<!-- For pre-release versions, use different formats for different purposes -->
			<MainVersion Condition="'$(IsPrerelease)' == 'true'">$(Version.Split('-')[0])</MainVersion>
			<MainVersion Condition="'$(IsPrerelease)' == 'false'">$(Version)</MainVersion>

			<!-- Define file path for AssemblyInfo -->
			<MrVersionAssemblyInfoFile>$(IntermediateOutputPath)$(MSBuildProjectName).mrv.g.cs</MrVersionAssemblyInfoFile>
		</PropertyGroup>

		<!-- Ensure directory exists -->
		<MakeDir Directories="$(IntermediateOutputPath)" />

		<!-- Generate $(MSBuildProjectName).mrv.g.cs file with assembly attributes -->
		<WriteLinesToFile File="$(MrVersionAssemblyInfoFile)"
            Lines="// &lt;auto-generated&gt;;// This code was generated by Mister.Version;// &lt;/auto-generated&gt;;;using System.Reflection%3B;;[assembly: AssemblyVersion(&quot;$(MainVersion)&quot;)];[assembly: AssemblyFileVersion(&quot;$(MainVersion)&quot;)];[assembly: AssemblyInformationalVersion(&quot;$(Version)&quot;)]"
            Overwrite="true" />

		<!-- Add the generated AssemblyInfo file to the compilation -->
		<ItemGroup>
			<Compile Include="$(MrVersionAssemblyInfoFile)" />
			<CalculatedProjectVersions Include="$(MSBuildProjectName):$(MainVersion)" />
		</ItemGroup>

        <Message Text="MonoRepo Versioning: Generated AssemblyInfo for $(MSBuildProjectName) with version $(Version)" Importance="High" />
		<Message Text="   -> $(MrVersionAssemblyInfoFile)" Importance="High" />
	</Target>

	<!-- Handle multi-targeting scenarios -->
	<!-- ENABLE versioning during cross-targeting build (outer build) for NuGet Pack -->
	<!-- NuGet Pack runs during the outer build and needs access to the calculated version -->
	<!-- The versioning task will also run during the inner builds for each specific TargetFramework -->
	<!-- This ensures both Pack (outer) and Build (inner) have correct version information -->
	<PropertyGroup Condition="'$(IsCrossTargetingBuild)' == 'true' and '$(IsPackable)' == 'true'">
		<!-- Keep versioning enabled for packable projects during cross-targeting -->
		<MonoRepoVersioningEnabled>true</MonoRepoVersioningEnabled>
	</PropertyGroup>

	<!-- CRITICAL FIX: Use GenerateNuspecDependsOn to inject versioning before nuspec generation -->
	<!-- This is the officially supported extension point for Pack customization -->
	<PropertyGroup Condition="'$(IsCrossTargetingBuild)' == 'true' and '$(IsPackable)' == 'true'">
		<GenerateNuspecDependsOn>$(GenerateNuspecDependsOn);_MonoRepoSetVersionForOuterBuild</GenerateNuspecDependsOn>
	</PropertyGroup>

	<!-- This target runs before nuspec generation during outer build -->
	<Target Name="_MonoRepoSetVersionForOuterBuild"
	        Condition="'$(IsCrossTargetingBuild)' == 'true' and '$(IsPackable)' == 'true'">
		<Message Importance="High" Text="[GenerateNuspec] Running versioning for outer build before nuspec generation" />

		<!-- Run the versioning task directly during outer build -->
		<ItemGroup>
			<_MonoRepoDependencies Include="@(ProjectReference)" />
		</ItemGroup>

		<MonoRepoVersionTask
			ProjectPath="$(MSBuildProjectFullPath)"
			RepoRoot="$(MonoRepoRoot)"
			TagPrefix="$(MonoRepoTagPrefix)"
			UpdateProjectFile="$(MonoRepoUpdateProjectFile)"
			ForceVersion="$(ForceVersion)"
			Debug="$(MonoRepoDebug)"
			ExtraDebug="$(MonoRepoExtraDebug)"
			SkipTestProjects="$(MonoRepoSkipTestProjects)"
			SkipNonPackableProjects="$(MonoRepoSkipNonPackableProjects)"
			IsTestProject="$(IsTestProject)"
			IsPackable="$(IsPackable)"
			PrereleaseType="$(MonoRepoPrereleaseType)"
			ConfigFile="$(MonoRepoConfigFile)"
			Dependencies="@(_MonoRepoDependencies)">
			<Output TaskParameter="Version" PropertyName="FullVersion" />
			<Output TaskParameter="VersionChanged" PropertyName="VersionChanged" />
			<Output TaskParameter="DiscoveredRepoRoot" PropertyName="DiscoveredRepoRoot" />
		</MonoRepoVersionTask>

		<!-- Calculate MainVersion for outer build -->
		<PropertyGroup>
			<IsPrerelease Condition="$(FullVersion.Contains('-'))">true</IsPrerelease>
			<IsPrerelease Condition="!$(FullVersion.Contains('-'))">false</IsPrerelease>
			<MainVersion Condition="'$(IsPrerelease)' == 'true'">$(FullVersion.Split('-')[0])</MainVersion>
			<MainVersion Condition="'$(IsPrerelease)' == 'false'">$(FullVersion)</MainVersion>
		</PropertyGroup>

		<!-- Force version properties for nuspec generation -->
		<PropertyGroup>
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
			<AssemblyVersion>$(MainVersion)</AssemblyVersion>
			<FileVersion>$(MainVersion)</FileVersion>
			<InformationalVersion>$(FullVersion)</InformationalVersion>
		</PropertyGroup>

		<Message Importance="High" Text="[GenerateNuspec] Set PackageVersion=$(PackageVersion) for outer build nuspec" />
	</Target>

	<!-- Ensure version is set before generating nuspec - run VERY early -->
	<Target Name="_EnsureVersionForPack" BeforeTargets="GenerateNuspec;GetTargetPath;Build;Pack;_LoadPackInputItems" DependsOnTargets="_MonoRepoSetVersion">
		<PropertyGroup>
			<!-- Force the package version to use our calculated version -->
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
			<AssemblyVersion>$(MainVersion)</AssemblyVersion>
			<FileVersion>$(MainVersion)</FileVersion>
			<InformationalVersion>$(FullVersion)</InformationalVersion>
		</PropertyGroup>
		<Message Importance="High" Text="[Pack] FORCING package version: $(PackageId) = $(PackageVersion)" />
	</Target>

	<!-- Force version recalculation before pack operations -->
	<Target Name="_ForceVersionRecalculation" BeforeTargets="GenerateNuspec;Pack;_LoadPackInputItems" DependsOnTargets="_MonoRepoSetVersion" Condition="'$(IsPackable)' == 'true'">
		<Message Importance="High" Text="[ForceRecalc] Ensuring latest version for pack: $(MSBuildProjectName) = $(FullVersion)" Condition="'$(MonoRepoDebug)'=='true'" />
	</Target>

	<!-- Property-based version calculation that runs during evaluation phase -->
	<PropertyGroup Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsPackable)' == 'true' and '$(IsTestProject)' != 'true' and '$(FullVersion)' != ''">
		<!-- Force version properties to be calculated during property evaluation when we have a version -->
		<PackageVersion>$(FullVersion)</PackageVersion>
		<Version>$(FullVersion)</Version>
		<AssemblyVersion>$(MainVersion)</AssemblyVersion>
		<FileVersion>$(MainVersion)</FileVersion>
		<InformationalVersion>$(FullVersion)</InformationalVersion>

		<!-- Force immediate property evaluation -->
		<_MrVersionCalculated>$(FullVersion)</_MrVersionCalculated>
	</PropertyGroup>

	<!-- Early version calculation before property evaluation -->
	<Target Name="_MonoRepoSetVersionEarly"
            BeforeTargets="CollectPackageReferences;_LoadPackInputItems;GetTargetPath;ResolvePackageAssets;GenerateNuspec"
            DependsOnTargets="_MonoRepoSetVersion"
            Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsPackable)' == 'true'">

		<PropertyGroup>
			<!-- Override default version properties with our calculated versions -->
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
			<AssemblyVersion>$(MainVersion)</AssemblyVersion>
			<FileVersion>$(MainVersion)</FileVersion>
			<InformationalVersion>$(FullVersion)</InformationalVersion>

			<!-- Force immediate re-evaluation -->
			<_ForceVersionUpdate>$(FullVersion)</_ForceVersionUpdate>
		</PropertyGroup>

		<Message Importance="High" Text="[EarlyVersion] Set package version during property evaluation: $(PackageVersion)" />
	</Target>

	<!-- Force property re-evaluation by overriding NuGet's property discovery -->
	<Target Name="_OverridePackageProperties"
            BeforeTargets="_GetTargetFrameworksOutput;_GetBuildOutputFilesWithTfm"
            DependsOnTargets="_MonoRepoSetVersion"
            Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsPackable)' == 'true'">

		<!-- Create items that force property updates -->
		<ItemGroup>
			<_VersionProperty Include="PackageVersion">
				<Value>$(FullVersion)</Value>
			</_VersionProperty>
			<_VersionProperty Include="Version">
				<Value>$(FullVersion)</Value>
			</_VersionProperty>
		</ItemGroup>

		<!-- Update global properties -->
		<CreateProperty Value="$(FullVersion)">
			<Output TaskParameter="ValueSetByTask" PropertyName="PackageVersion" />
		</CreateProperty>
		<CreateProperty Value="$(FullVersion)">
			<Output TaskParameter="ValueSetByTask" PropertyName="Version" />
		</CreateProperty>

		<Message Importance="High" Text="[PropertyOverride] Forced PackageVersion=$(PackageVersion), Version=$(Version)" />
	</Target>


	<!-- Force version calculation during pack operation -->
	<Target Name="_ForceVersionCalculationForPack" BeforeTargets="Pack;GenerateNuspec;_LoadPackInputItems" DependsOnTargets="_MonoRepoSetVersion">
		<Message Importance="High" Text="[PackMain] Ensuring version calculation for main project: $(MSBuildProjectName) = $(FullVersion)" />
	</Target>

	<!-- Additional hook for pack to ensure main project versioning -->
	<Target Name="_EnsureMainProjectVersionForPack" BeforeTargets="_LoadPackInputItems;_GetTargetFrameworksOutput" DependsOnTargets="_MonoRepoSetVersion" Condition="'$(IsPackable)' == 'true'">
		<PropertyGroup>
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
		</PropertyGroup>
		<Message Importance="High" Text="[PackMain] Main project version set: $(MSBuildProjectName) = $(PackageVersion)" />
	</Target>

	<Target Name="_GenerateVersionForNuspec" BeforeTargets="Pack" DependsOnTargets="_MonoRepoSetVersion" Inputs="$(SanitizedProjectName).csproj" Outputs="$(SanitizedProjectName).mrv.g.cs">
		<Message Importance="High" Text="Detected version: $(PackageId); $(PackageVersion)" />
	</Target>

	<!-- Target to provide package version for ProjectReference resolution -->
	<!-- This ensures dependent projects get the correct version during Pack -->

	<!-- REAL FIX: Hook into GetTargetPath to provide correct version information -->
	<!-- This target is called during cross-project references and dependency resolution -->
	<Target Name="GetTargetPath"
            DependsOnTargets="_MonoRepoSetVersion"
            Returns="@(TargetPathWithTargetPlatformMoniker)"
            Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsTestProject)' != 'true'">

		<!-- Ensure we have the latest calculated version - ALWAYS override -->
		<PropertyGroup>
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
		</PropertyGroup>

		<ItemGroup>
			<TargetPathWithTargetPlatformMoniker Include="$(TargetPath)">
				<TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
				<TargetPlatformIdentifier>$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
				<PackageVersion>$(FullVersion)</PackageVersion>
				<Version>$(FullVersion)</Version>
				<ProjectName>$(MSBuildProjectName)</ProjectName>
			</TargetPathWithTargetPlatformMoniker>
		</ItemGroup>

		<Message Text="[MRV-GetTargetPath] Providing version $(FullVersion) for cross-project reference $(MSBuildProjectName)" Importance="High" Condition="'$(MonoRepoDebug)'=='true'" />
	</Target>

	<!-- Override the GetPackageVersion target to ensure it returns calculated versions -->
	<!-- This target is called by NuGet Pack to get the package version -->
	<Target Name="_GetPackageVersion"
            DependsOnTargets="_MonoRepoSetVersion"
            Returns="$(FullVersion)"
            Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsTestProject)' != 'true'">
		<PropertyGroup>
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
		</PropertyGroup>
		<Message Text="[MRV-GetPackageVersion] Returning PackageVersion=$(FullVersion) for $(MSBuildProjectName) (IsCrossTargetingBuild=$(IsCrossTargetingBuild))" Importance="High" />
	</Target>



	<!-- CRITICAL: This target is called by NuGet Pack's _GetProjectReferenceVersions -->
	<!-- It MUST return an item with ProjectVersion metadata for NuGet dependency resolution -->
	<Target Name="_GetProjectVersion"
            DependsOnTargets="_MonoRepoSetVersion"
            Returns="@(_ProjectPathWithVersion)">

		<Message Importance="High" Text="[_GetProjectVersion] CALLED by NuGet Pack for $(MSBuildProjectName)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
		<Message Importance="High" Text="[_GetProjectVersion] PackageVersion: $(PackageVersion)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
		<Message Importance="High" Text="[_GetProjectVersion] FullVersion: $(FullVersion)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />

		<PropertyGroup>
			<!-- Determine version to return -->
			<_VersionForPack Condition="'$(FullVersion)' != ''">$(FullVersion)</_VersionForPack>
			<_VersionForPack Condition="'$(_VersionForPack)' == '' and '$(PackageVersion)' != ''">$(PackageVersion)</_VersionForPack>
			<_VersionForPack Condition="'$(_VersionForPack)' == '' and '$(Version)' != ''">$(Version)</_VersionForPack>
			<_VersionForPack Condition="'$(_VersionForPack)' == ''">1.0.0</_VersionForPack>
		</PropertyGroup>

		<ItemGroup>
			<_ProjectPathWithVersion Include="$(MSBuildProjectFullPath)">
				<ProjectVersion>$(_VersionForPack)</ProjectVersion>
			</_ProjectPathWithVersion>
		</ItemGroup>

		<Message Importance="High" Text="[_GetProjectVersion] RETURNING version: $(_VersionForPack)" Condition="'$(MonoRepoExtraDebug)' == 'true'" />
	</Target>

	<!--
	EXPERIMENTAL TARGETS - NOT NEEDED FOR INNER BUILD
	These approaches were tried but the actual fix uses GetPackageVersionDependsOn + _GetProjectVersion.
	Keeping commented for reference.

	<Target Name="GetTargetFrameworksWithPlatformFromInnerBuilds">
		Hook to provide version during project reference resolution
	</Target>

		Inline task for experimental dependency injection
	</UsingTask>

	<Target Name="_SetProjectReferenceVersions">
		Experimental: Override ProjectReference metadata for NuGet dependency resolution
	</Target>

	<Target Name="_SetResolvedProjectReferenceVersions">
		Experimental: Update _ResolvedProjectReferencePaths for NuGet Pack
	</Target>

	<Target Name="_MonoRepoGetPackageVersion">
		Experimental: Helper target that returns package version
	</Target>

	<Target Name="_SetProjectReferenceVersionsForDepsJson">
		Experimental: Hook into deps.json generation
	</Target>

	<Target Name="_EnhancedGetTargetPathForDeps">
		Experimental: Enhanced GetTargetPath for deps.json generation
	</Target>

	<Target Name="_EnsureAssemblyVersionForDepsFile">
		Experimental: Fallback to ensure AssemblyVersion is set
	</Target>
	-->

</Project>