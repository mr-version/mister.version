<?xml version="1.0" encoding="utf-8"?>
<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<!-- Include the versioning task -->
	<UsingTask TaskName="Mister.Version.MonoRepoVersionTask" AssemblyFile="$(MSBuildThisFileDirectory)../tasks/$(AppSettingStronglyTyped_TFM)/Mister.Version.dll" />

	<!-- CRITICAL: Ensure test projects have versions set immediately to prevent GenerateDepsFile errors -->
	<PropertyGroup Condition="'$(IsTestProject)' == 'true'">
		<AssemblyVersion Condition="'$(AssemblyVersion)' == ''">1.0.0.0</AssemblyVersion>
		<FileVersion Condition="'$(FileVersion)' == ''">1.0.0.0</FileVersion>
		<Version Condition="'$(Version)' == ''">1.0.0</Version>
		<PackageVersion Condition="'$(PackageVersion)' == ''">1.0.0</PackageVersion>
		<InformationalVersion Condition="'$(InformationalVersion)' == ''">1.0.0</InformationalVersion>
		<MonoRepoVersioningEnabled>false</MonoRepoVersioningEnabled>
	</PropertyGroup>

	<!-- Initial target to set version properties early in MSBuild evaluation -->
	<Target Name="_MonoRepoSetVersion"
        Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsTestProject)' != 'true'">
		<!-- Automatically detect dependencies based on ProjectReference -->
		<ItemGroup>
			<_MonoRepoDependencies Include="@(ProjectReference)" />
		</ItemGroup>

		<!-- Run the versioning task to get the version -->
		<MonoRepoVersionTask ProjectPath="$(MSBuildProjectFullPath)" RepoRoot="$(MonoRepoRoot)" TagPrefix="$(MonoRepoTagPrefix)" UpdateProjectFile="$(MonoRepoUpdateProjectFile)" ForceVersion="$(ForceVersion)" Debug="$(MonoRepoDebug)" ExtraDebug="$(MonoRepoExtraDebug)" SkipTestProjects="$(MonoRepoSkipTestProjects)" SkipNonPackableProjects="$(MonoRepoSkipNonPackableProjects)" IsTestProject="$(IsTestProject)" IsPackable="$(IsPackable)" PrereleaseType="$(MonoRepoPrereleaseType)" ConfigFile="$(MonoRepoConfigFile)" Dependencies="@(_MonoRepoDependencies)">
			<Output TaskParameter="Version" PropertyName="FullVersion" />
			<Output TaskParameter="VersionChanged" PropertyName="VersionChanged" />
			<Output TaskParameter="DiscoveredRepoRoot" PropertyName="DiscoveredRepoRoot" />
		</MonoRepoVersionTask>

		<!-- Calculate different version formats -->
		<PropertyGroup>
			<IsPrerelease Condition="$(FullVersion.Contains('-'))">true</IsPrerelease>
			<IsPrerelease Condition="!$(FullVersion.Contains('-'))">false</IsPrerelease>
			<MainVersion Condition="'$(IsPrerelease)' == 'true'">$(FullVersion.Split('-')[0])</MainVersion>
			<MainVersion Condition="'$(IsPrerelease)' == 'false'">$(FullVersion)</MainVersion>
		</PropertyGroup>

		<!-- Write version to TFM-specific location for current build -->
		<PropertyGroup>
			<MrVersionAssemblyRefFile>$(IntermediateOutputPath)$(MSBuildProjectName).version.props</MrVersionAssemblyRefFile>
		</PropertyGroup>

		<!-- Ensure obj directory exists -->
		<MakeDir Directories="$(IntermediateOutputPath)" />

		<!-- Write version properties to TFM-specific file -->
		<WriteLinesToFile File="$(MrVersionAssemblyRefFile)"
            Lines="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;;&lt;Project&gt;;&lt;PropertyGroup&gt;;&lt;PackageVersion&gt;$(FullVersion)&lt;/PackageVersion&gt;;&lt;Version&gt;$(FullVersion)&lt;/Version&gt;;&lt;AssemblyVersion&gt;$(MainVersion)&lt;/AssemblyVersion&gt;;&lt;FileVersion&gt;$(MainVersion)&lt;/FileVersion&gt;;&lt;InformationalVersion&gt;$(FullVersion)&lt;/InformationalVersion&gt;;&lt;/PropertyGroup&gt;;&lt;/Project&gt;"
            Overwrite="true" />

		<!-- ALSO write to TFM-agnostic location for cross-project queries -->
		<!-- Only write from first TFM to avoid parallel file access conflicts -->
		<PropertyGroup>
			<_SharedVersionPropsPath>$(MSBuildProjectDirectory)\obj\$(Configuration)\$(MSBuildProjectName).outerbuild.version.props</_SharedVersionPropsPath>
			<_ShouldWriteSharedVersion>false</_ShouldWriteSharedVersion>
			<!-- Write if file doesn't exist OR if this is the first TFM in TargetFrameworks -->
			<_ShouldWriteSharedVersion Condition="!Exists('$(_SharedVersionPropsPath)')">true</_ShouldWriteSharedVersion>
			<!-- Only write from one TFM to prevent conflicts - use the first one alphabetically -->
			<_FirstTargetFramework>$(TargetFrameworks.Split(';')[0])</_FirstTargetFramework>
			<_ShouldWriteSharedVersion Condition="'$(TargetFramework)' == '$(_FirstTargetFramework)'">true</_ShouldWriteSharedVersion>
			<!-- Always write if not multi-targeting -->
			<_ShouldWriteSharedVersion Condition="'$(TargetFrameworks)' == ''">true</_ShouldWriteSharedVersion>
		</PropertyGroup>

		<MakeDir Directories="$(MSBuildProjectDirectory)\obj\$(Configuration)" Condition="'$(_ShouldWriteSharedVersion)' == 'true'" />

		<ItemGroup Condition="'$(_ShouldWriteSharedVersion)' == 'true'">
			<_SharedVersionLines Include="&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;" />
			<_SharedVersionLines Include="&lt;Project&gt;" />
			<_SharedVersionLines Include="  &lt;PropertyGroup&gt;" />
			<_SharedVersionLines Include="    &lt;!-- Generated by Mister.Version for cross-project version queries --&gt;" />
			<_SharedVersionLines Include="    &lt;PackageVersion&gt;$(FullVersion)&lt;/PackageVersion&gt;" />
			<_SharedVersionLines Include="    &lt;Version&gt;$(FullVersion)&lt;/Version&gt;" />
			<_SharedVersionLines Include="    &lt;AssemblyVersion&gt;$(MainVersion)&lt;/AssemblyVersion&gt;" />
			<_SharedVersionLines Include="    &lt;FileVersion&gt;$(MainVersion)&lt;/FileVersion&gt;" />
			<_SharedVersionLines Include="    &lt;InformationalVersion&gt;$(FullVersion)&lt;/InformationalVersion&gt;" />
			<_SharedVersionLines Include="  &lt;/PropertyGroup&gt;" />
			<_SharedVersionLines Include="&lt;/Project&gt;" />
		</ItemGroup>

		<!-- Write with error handling for concurrent access -->
		<WriteLinesToFile File="$(_SharedVersionPropsPath)"
		                  Lines="@(_SharedVersionLines)"
		                  Overwrite="true"
		                  WriteOnlyWhenDifferent="true"
		                  ContinueOnError="true"
		                  Condition="'$(_ShouldWriteSharedVersion)' == 'true'" />

		<Message Text="[MrVersion] Written version properties to: $(MrVersionAssemblyRefFile)" Importance="High" Condition="'$(MonoRepoDebug)'=='true'" />
		<Message Text="[MrVersion] Written shared version to: $(_SharedVersionPropsPath)" Importance="High" Condition="'$(MonoRepoDebug)'=='true'" />

		<!-- Force immediate property update using CreateProperty tasks -->
		<CreateProperty Value="$(FullVersion)" Condition="'$(IsPackable)' == 'true'">
			<Output TaskParameter="ValueSetByTask" PropertyName="PackageVersion" />
		</CreateProperty>
		<CreateProperty Value="$(FullVersion)" Condition="'$(IsPackable)' == 'true'">
			<Output TaskParameter="ValueSetByTask" PropertyName="Version" />
		</CreateProperty>
		<PropertyGroup>
			<IsPrerelease Condition="$(FullVersion.Contains('-'))">true</IsPrerelease>
			<IsPrerelease Condition="!$(FullVersion.Contains('-'))">false</IsPrerelease>
			<MainVersion Condition="'$(IsPrerelease)' == 'true'">$(FullVersion.Split('-')[0])</MainVersion>
			<MainVersion Condition="'$(IsPrerelease)' == 'false'">$(FullVersion)</MainVersion>
		</PropertyGroup>

		<!-- Disable automatic assembly info generation -->
		<CreateProperty Value="false">
			<Output TaskParameter="ValueSetByTask" PropertyName="GenerateAssemblyVersionAttribute" />
		</CreateProperty>
		<CreateProperty Value="false">
			<Output TaskParameter="ValueSetByTask" PropertyName="GenerateAssemblyFileVersionAttribute" />
		</CreateProperty>
		<CreateProperty Value="false">
			<Output TaskParameter="ValueSetByTask" PropertyName="GenerateAssemblyInformationalVersionAttribute" />
		</CreateProperty>

		<ItemGroup>
			<ProjectVersionInfo Include="$(MSBuildProjectName)">
				<FullVersion>$(FullVersion)</FullVersion>
				<MainVersion>$(MainVersion)</MainVersion>
				<IsPrerelease>$(IsPrerelease)</IsPrerelease>
			</ProjectVersionInfo>
		</ItemGroup>

		<PropertyGroup>
			<!-- Get the version for the specific project -->
			<RetrievedVersion>@(ProjectVersionInfo->WithMetadataValue('Identity', '$(MSBuildProjectName)')->Metadata('FullVersion'))</RetrievedVersion>
			<IsPrerelease Condition="$(FullVersion.Contains('-'))">true</IsPrerelease>
			<IsPrerelease Condition="!$(FullVersion.Contains('-'))">false</IsPrerelease>
			<MainVersion Condition="'$(IsPrerelease)' == 'true'">$(FullVersion.Split('-')[0])</MainVersion>
			<MainVersion Condition="'$(IsPrerelease)' == 'false'">$(FullVersion)</MainVersion>

			<!-- Set Version Properties with immediate evaluation - override with calculated version when available -->
			<Version Condition="'$(FullVersion)' != ''">$(FullVersion)</Version>
			<PackageVersion Condition="'$(FullVersion)' != ''">$(FullVersion)</PackageVersion>
			<AssemblyVersion Condition="'$(FullVersion)' != ''">$(MainVersion)</AssemblyVersion>
			<FileVersion Condition="'$(FullVersion)' != ''">$(MainVersion)</FileVersion>
			<InformationalVersion Condition="'$(FullVersion)' != ''">$(FullVersion)</InformationalVersion>

			<!-- Ensure properties are available for NuGet property evaluation -->
			<_MrVersionCalculated>$(FullVersion)</_MrVersionCalculated>

			<!-- Disable automatic assembly info generation to avoid duplicates -->
			<GenerateAssemblyInfo>true</GenerateAssemblyInfo>
			<GenerateAssemblyVersionAttribute>false</GenerateAssemblyVersionAttribute>
			<GenerateAssemblyFileVersionAttribute>false</GenerateAssemblyFileVersionAttribute>
			<GenerateAssemblyInformationalVersionAttribute>false</GenerateAssemblyInformationalVersionAttribute>
		</PropertyGroup>

        <Message Text="MonoRepo Versioning: Set version $(FullVersion) for $(MSBuildProjectName)" Importance="High" Condition="'$(MonoRepoDebug)'=='true'"/>
	</Target>

	<!-- Generate AssemblyInfo file during normal build process - run VERY early -->
	<Target Name="_MonoRepoCalculateVersion"
        DependsOnTargets="_MonoRepoSetVersion"
        BeforeTargets="GetAssemblyAttributes;GenerateAssemblyInfo;CoreGenerateAssemblyInfo;PrepareForBuild"
        Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsTestProject)' != 'true'">
		<!-- Use the version from the generated props file (which should be imported by now) -->
		<PropertyGroup>
			<!-- Check if this is a pre-release version (has a dash) -->
			<IsPrerelease Condition="$(Version.Contains('-'))">true</IsPrerelease>
			<IsPrerelease Condition="!$(Version.Contains('-'))">false</IsPrerelease>

			<!-- For pre-release versions, use different formats for different purposes -->
			<MainVersion Condition="'$(IsPrerelease)' == 'true'">$(Version.Split('-')[0])</MainVersion>
			<MainVersion Condition="'$(IsPrerelease)' == 'false'">$(Version)</MainVersion>

			<!-- Define file path for AssemblyInfo -->
			<MrVersionAssemblyInfoFile>$(IntermediateOutputPath)$(MSBuildProjectName).mrv.g.cs</MrVersionAssemblyInfoFile>
		</PropertyGroup>

		<!-- Ensure directory exists -->
		<MakeDir Directories="$(IntermediateOutputPath)" />

		<!-- Generate $(MSBuildProjectName).mrv.g.cs file with assembly attributes -->
		<WriteLinesToFile File="$(MrVersionAssemblyInfoFile)"
            Lines="// &lt;auto-generated&gt;;// This code was generated by Mister.Version;// &lt;/auto-generated&gt;;;using System.Reflection%3B;;[assembly: AssemblyVersion(&quot;$(MainVersion)&quot;)];[assembly: AssemblyFileVersion(&quot;$(MainVersion)&quot;)];[assembly: AssemblyInformationalVersion(&quot;$(Version)&quot;)]"
            Overwrite="true" />

		<!-- Add the generated AssemblyInfo file to the compilation -->
		<ItemGroup>
			<Compile Include="$(MrVersionAssemblyInfoFile)" />
			<CalculatedProjectVersions Include="$(MSBuildProjectName):$(MainVersion)" />
		</ItemGroup>

        <Message Text="MonoRepo Versioning: Generated AssemblyInfo for $(MSBuildProjectName) with version $(Version)" Importance="High" />
		<Message Text="   -> $(MrVersionAssemblyInfoFile)" Importance="High" />
	</Target>

	<!-- Handle multi-targeting scenarios -->
	<!-- ENABLE versioning during cross-targeting build (outer build) for NuGet Pack -->
	<!-- NuGet Pack runs during the outer build and needs access to the calculated version -->
	<!-- The versioning task will also run during the inner builds for each specific TargetFramework -->
	<!-- This ensures both Pack (outer) and Build (inner) have correct version information -->
	<PropertyGroup Condition="'$(IsCrossTargetingBuild)' == 'true' and '$(IsPackable)' == 'true'">
		<!-- Keep versioning enabled for packable projects during cross-targeting -->
		<MonoRepoVersioningEnabled>true</MonoRepoVersioningEnabled>
	</PropertyGroup>

	<!-- CRITICAL FIX: Use GenerateNuspecDependsOn to inject versioning before nuspec generation -->
	<!-- This is the officially supported extension point for Pack customization -->
	<PropertyGroup Condition="'$(IsCrossTargetingBuild)' == 'true' and '$(IsPackable)' == 'true'">
		<GenerateNuspecDependsOn>$(GenerateNuspecDependsOn);_MonoRepoSetVersionForOuterBuild</GenerateNuspecDependsOn>
	</PropertyGroup>

	<!-- This target runs before nuspec generation during outer build -->
	<Target Name="_MonoRepoSetVersionForOuterBuild"
	        Condition="'$(IsCrossTargetingBuild)' == 'true' and '$(IsPackable)' == 'true'">
		<Message Importance="High" Text="[GenerateNuspec] Running versioning for outer build before nuspec generation" />

		<!-- Run the versioning task directly during outer build -->
		<ItemGroup>
			<_MonoRepoDependencies Include="@(ProjectReference)" />
		</ItemGroup>

		<MonoRepoVersionTask
			ProjectPath="$(MSBuildProjectFullPath)"
			RepoRoot="$(MonoRepoRoot)"
			TagPrefix="$(MonoRepoTagPrefix)"
			UpdateProjectFile="$(MonoRepoUpdateProjectFile)"
			ForceVersion="$(ForceVersion)"
			Debug="$(MonoRepoDebug)"
			ExtraDebug="$(MonoRepoExtraDebug)"
			SkipTestProjects="$(MonoRepoSkipTestProjects)"
			SkipNonPackableProjects="$(MonoRepoSkipNonPackableProjects)"
			IsTestProject="$(IsTestProject)"
			IsPackable="$(IsPackable)"
			PrereleaseType="$(MonoRepoPrereleaseType)"
			ConfigFile="$(MonoRepoConfigFile)"
			Dependencies="@(_MonoRepoDependencies)">
			<Output TaskParameter="Version" PropertyName="FullVersion" />
			<Output TaskParameter="VersionChanged" PropertyName="VersionChanged" />
			<Output TaskParameter="DiscoveredRepoRoot" PropertyName="DiscoveredRepoRoot" />
		</MonoRepoVersionTask>

		<!-- Calculate MainVersion for outer build -->
		<PropertyGroup>
			<IsPrerelease Condition="$(FullVersion.Contains('-'))">true</IsPrerelease>
			<IsPrerelease Condition="!$(FullVersion.Contains('-'))">false</IsPrerelease>
			<MainVersion Condition="'$(IsPrerelease)' == 'true'">$(FullVersion.Split('-')[0])</MainVersion>
			<MainVersion Condition="'$(IsPrerelease)' == 'false'">$(FullVersion)</MainVersion>
		</PropertyGroup>

		<!-- Force version properties for nuspec generation -->
		<PropertyGroup>
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
			<AssemblyVersion>$(MainVersion)</AssemblyVersion>
			<FileVersion>$(MainVersion)</FileVersion>
			<InformationalVersion>$(FullVersion)</InformationalVersion>
		</PropertyGroup>

		<Message Importance="High" Text="[GenerateNuspec] Set PackageVersion=$(PackageVersion) for outer build nuspec" />
	</Target>

	<!-- Ensure version is set before generating nuspec - run VERY early -->
	<Target Name="_EnsureVersionForPack" BeforeTargets="GenerateNuspec;GetTargetPath;Build;Pack;_LoadPackInputItems" DependsOnTargets="_MonoRepoSetVersion">
		<PropertyGroup>
			<!-- Force the package version to use our calculated version -->
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
			<AssemblyVersion>$(MainVersion)</AssemblyVersion>
			<FileVersion>$(MainVersion)</FileVersion>
			<InformationalVersion>$(FullVersion)</InformationalVersion>
		</PropertyGroup>
		<Message Importance="High" Text="[Pack] FORCING package version: $(PackageId) = $(PackageVersion)" />
	</Target>

	<!-- Force version recalculation before pack operations -->
	<Target Name="_ForceVersionRecalculation" BeforeTargets="GenerateNuspec;Pack;_LoadPackInputItems" DependsOnTargets="_MonoRepoSetVersion" Condition="'$(IsPackable)' == 'true'">
		<Message Importance="High" Text="[ForceRecalc] Ensuring latest version for pack: $(MSBuildProjectName) = $(FullVersion)" Condition="'$(MonoRepoDebug)'=='true'" />
	</Target>

	<!-- Property-based version calculation that runs during evaluation phase -->
	<PropertyGroup Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsPackable)' == 'true' and '$(IsTestProject)' != 'true' and '$(FullVersion)' != ''">
		<!-- Force version properties to be calculated during property evaluation when we have a version -->
		<PackageVersion>$(FullVersion)</PackageVersion>
		<Version>$(FullVersion)</Version>
		<AssemblyVersion>$(MainVersion)</AssemblyVersion>
		<FileVersion>$(MainVersion)</FileVersion>
		<InformationalVersion>$(FullVersion)</InformationalVersion>

		<!-- Force immediate property evaluation -->
		<_MrVersionCalculated>$(FullVersion)</_MrVersionCalculated>
	</PropertyGroup>

	<!-- Early version calculation before property evaluation -->
	<Target Name="_MonoRepoSetVersionEarly"
            BeforeTargets="CollectPackageReferences;_LoadPackInputItems;GetTargetPath;ResolvePackageAssets;GenerateNuspec"
            DependsOnTargets="_MonoRepoSetVersion"
            Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsPackable)' == 'true'">

		<PropertyGroup>
			<!-- Override default version properties with our calculated versions -->
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
			<AssemblyVersion>$(MainVersion)</AssemblyVersion>
			<FileVersion>$(MainVersion)</FileVersion>
			<InformationalVersion>$(FullVersion)</InformationalVersion>

			<!-- Force immediate re-evaluation -->
			<_ForceVersionUpdate>$(FullVersion)</_ForceVersionUpdate>
		</PropertyGroup>

		<Message Importance="High" Text="[EarlyVersion] Set package version during property evaluation: $(PackageVersion)" />
	</Target>

	<!-- Force property re-evaluation by overriding NuGet's property discovery -->
	<Target Name="_OverridePackageProperties"
            BeforeTargets="_GetTargetFrameworksOutput;_GetBuildOutputFilesWithTfm"
            DependsOnTargets="_MonoRepoSetVersion"
            Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsPackable)' == 'true'">

		<!-- Create items that force property updates -->
		<ItemGroup>
			<_VersionProperty Include="PackageVersion">
				<Value>$(FullVersion)</Value>
			</_VersionProperty>
			<_VersionProperty Include="Version">
				<Value>$(FullVersion)</Value>
			</_VersionProperty>
		</ItemGroup>

		<!-- Update global properties -->
		<CreateProperty Value="$(FullVersion)">
			<Output TaskParameter="ValueSetByTask" PropertyName="PackageVersion" />
		</CreateProperty>
		<CreateProperty Value="$(FullVersion)">
			<Output TaskParameter="ValueSetByTask" PropertyName="Version" />
		</CreateProperty>

		<Message Importance="High" Text="[PropertyOverride] Forced PackageVersion=$(PackageVersion), Version=$(Version)" />
	</Target>


	<!-- Force version calculation during pack operation -->
	<Target Name="_ForceVersionCalculationForPack" BeforeTargets="Pack;GenerateNuspec;_LoadPackInputItems" DependsOnTargets="_MonoRepoSetVersion">
		<Message Importance="High" Text="[PackMain] Ensuring version calculation for main project: $(MSBuildProjectName) = $(FullVersion)" />
	</Target>

	<!-- Additional hook for pack to ensure main project versioning -->
	<Target Name="_EnsureMainProjectVersionForPack" BeforeTargets="_LoadPackInputItems;_GetTargetFrameworksOutput" DependsOnTargets="_MonoRepoSetVersion" Condition="'$(IsPackable)' == 'true'">
		<PropertyGroup>
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
		</PropertyGroup>
		<Message Importance="High" Text="[PackMain] Main project version set: $(MSBuildProjectName) = $(PackageVersion)" />
	</Target>

	<Target Name="_GenerateVersionForNuspec" BeforeTargets="Pack" DependsOnTargets="_MonoRepoSetVersion" Inputs="$(SanitizedProjectName).csproj" Outputs="$(SanitizedProjectName).mrv.g.cs">
		<Message Importance="High" Text="Detected version: $(PackageId); $(PackageVersion)" />
	</Target>

	<!-- Target to provide package version for ProjectReference resolution -->
	<!-- This ensures dependent projects get the correct version during Pack -->

	<!-- REAL FIX: Hook into GetTargetPath to provide correct version information -->
	<!-- This target is called during cross-project references and dependency resolution -->
	<Target Name="GetTargetPath"
            DependsOnTargets="_MonoRepoSetVersion"
            Returns="@(TargetPathWithTargetPlatformMoniker)"
            Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsTestProject)' != 'true'">

		<!-- Ensure we have the latest calculated version - ALWAYS override -->
		<PropertyGroup>
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
		</PropertyGroup>

		<ItemGroup>
			<TargetPathWithTargetPlatformMoniker Include="$(TargetPath)">
				<TargetPlatformMoniker>$(TargetPlatformMoniker)</TargetPlatformMoniker>
				<TargetPlatformIdentifier>$(TargetPlatformIdentifier)</TargetPlatformIdentifier>
				<PackageVersion>$(FullVersion)</PackageVersion>
				<Version>$(FullVersion)</Version>
				<ProjectName>$(MSBuildProjectName)</ProjectName>
			</TargetPathWithTargetPlatformMoniker>
		</ItemGroup>

		<Message Text="[MRV-GetTargetPath] Providing version $(FullVersion) for cross-project reference $(MSBuildProjectName)" Importance="High" Condition="'$(MonoRepoDebug)'=='true'" />
	</Target>

	<!-- Override the GetPackageVersion target to ensure it returns calculated versions -->
	<!-- This target is called by NuGet Pack to get the package version -->
	<Target Name="_GetPackageVersion"
            DependsOnTargets="_MonoRepoSetVersion"
            Returns="$(FullVersion)"
            Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsTestProject)' != 'true'">
		<PropertyGroup>
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
		</PropertyGroup>
		<Message Text="[MRV-GetPackageVersion] Returning PackageVersion=$(FullVersion) for $(MSBuildProjectName) (IsCrossTargetingBuild=$(IsCrossTargetingBuild))" Importance="High" />
	</Target>



	<!-- CRITICAL: This target is called by NuGet Pack's _GetProjectReferenceVersions -->
	<!-- It MUST return an item with ProjectVersion metadata for NuGet dependency resolution -->
	<Target Name="_GetProjectVersion"
            DependsOnTargets="_MonoRepoSetVersion"
            Returns="@(_ProjectPathWithVersion)">

		<Message Importance="High" Text="[_GetProjectVersion] CALLED by NuGet Pack for $(MSBuildProjectName)" />
		<Message Importance="High" Text="[_GetProjectVersion] PackageVersion: $(PackageVersion)" />
		<Message Importance="High" Text="[_GetProjectVersion] FullVersion: $(FullVersion)" />

		<PropertyGroup>
			<!-- Determine version to return -->
			<_VersionForPack Condition="'$(FullVersion)' != ''">$(FullVersion)</_VersionForPack>
			<_VersionForPack Condition="'$(_VersionForPack)' == '' and '$(PackageVersion)' != ''">$(PackageVersion)</_VersionForPack>
			<_VersionForPack Condition="'$(_VersionForPack)' == '' and '$(Version)' != ''">$(Version)</_VersionForPack>
			<_VersionForPack Condition="'$(_VersionForPack)' == ''">1.0.0</_VersionForPack>
		</PropertyGroup>

		<ItemGroup>
			<_ProjectPathWithVersion Include="$(MSBuildProjectFullPath)">
				<ProjectVersion>$(_VersionForPack)</ProjectVersion>
			</_ProjectPathWithVersion>
		</ItemGroup>

		<Message Importance="High" Text="[_GetProjectVersion] RETURNING version: $(_VersionForPack)" />
	</Target>

	<!-- Hook to provide version during project reference resolution -->
	<Target Name="GetTargetFrameworksWithPlatformFromInnerBuilds"
            Returns="@(TargetFrameworksWithPlatformFromInnerBuilds)"
            DependsOnTargets="_MonoRepoSetVersion">
		<ItemGroup>
			<TargetFrameworksWithPlatformFromInnerBuilds Include="$(TargetFramework)">
				<PackageVersion>$(PackageVersion)</PackageVersion>
				<Version>$(Version)</Version>
			</TargetFrameworksWithPlatformFromInnerBuilds>
		</ItemGroup>
	</Target>

	<!-- Inline task to match ProjectReferences with their resolved versions (inner build) -->
	<UsingTask TaskName="UpdateProjectReferenceVersionsInnerBuild" TaskFactory="RoslynCodeTaskFactory" AssemblyFile="$(MSBuildToolsPath)\Microsoft.Build.Tasks.Core.dll">
		<ParameterGroup>
			<ProjectReferences ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
			<ResolvedVersions ParameterType="Microsoft.Build.Framework.ITaskItem[]" Required="true" />
			<UpdatedProjectReferences ParameterType="Microsoft.Build.Framework.ITaskItem[]" Output="true" />
		</ParameterGroup>
		<Task>
			<Using Namespace="System" />
			<Using Namespace="System.IO" />
			<Using Namespace="System.Collections.Generic" />
			<Code Type="Fragment" Language="cs">
				<![CDATA[
				// Build a dictionary of project name -> version
				var versionLookup = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);
				foreach (var item in ResolvedVersions)
				{
					var projectName = item.ItemSpec;
					var version = item.GetMetadata("Version");
					versionLookup[projectName] = version;
					Log.LogMessage(MessageImportance.High, $"[InnerBuild-UpdateVersions] Lookup: {projectName} -> {version}");
				}

				// Update ProjectReference items with matching versions
				var updatedItems = new List<ITaskItem>();
				foreach (var projRef in ProjectReferences)
				{
					var projPath = projRef.ItemSpec;
					var projName = Path.GetFileNameWithoutExtension(projPath);

					// Copy all metadata
					var newItem = new Microsoft.Build.Utilities.TaskItem(projRef);

					// Set version if we found a match
					if (versionLookup.TryGetValue(projName, out var version))
					{
						newItem.SetMetadata("Version", version);
						newItem.SetMetadata("PackageVersion", version);
						Log.LogMessage(MessageImportance.High, $"[InnerBuild-UpdateVersions] Set {projName} -> {version}");
					}
					else
					{
						Log.LogMessage(MessageImportance.High, $"[InnerBuild-UpdateVersions] No version found for {projName}");
					}

					updatedItems.Add(newItem);
				}

				UpdatedProjectReferences = updatedItems.ToArray();
				]]>
			</Code>
		</Task>
	</UsingTask>

	<!-- REAL FIX: Override ProjectReference metadata for NuGet dependency resolution -->
	<!-- This target modifies ProjectReference items to include the correct version metadata -->
	<Target Name="_SetProjectReferenceVersions"
            DependsOnTargets="_MonoRepoSetVersion"
            BeforeTargets="_GetBuildOutputFilesWithTfm;_GetTargetFrameworksOutput;GenerateNuspec"
            Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsTestProject)' != 'true'">

		<Message Text="[InnerBuild-SetProjectRefVersions] START - Updating ProjectReference metadata for NuGet Pack" Importance="High" />
		<Message Text="[InnerBuild-SetProjectRefVersions] ProjectReferences BEFORE: @(ProjectReference->Count()) items" Importance="High" />

		<!-- Get each ProjectReference and ensure it has the correct version metadata -->
		<MSBuild Projects="@(ProjectReference)"
                 Targets="_MonoRepoGetPackageVersion"
                 BuildInParallel="$(BuildInParallel)"
                 Properties="$(MSBuildGlobalProperties)"
                 Condition="'$(MonoRepoVersioningEnabled)'=='true'"
                 ContinueOnError="WarnAndContinue">
			<Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceVersions" />
		</MSBuild>

		<Message Text="[InnerBuild-SetProjectRefVersions] Resolved versions: %(_ProjectReferenceVersions.Identity) = %(_ProjectReferenceVersions.Version)" Importance="High" />

		<!-- Use inline task to match and update ProjectReference metadata -->
		<UpdateProjectReferenceVersionsInnerBuild
			ProjectReferences="@(ProjectReference)"
			ResolvedVersions="@(_ProjectReferenceVersions)">
			<Output TaskParameter="UpdatedProjectReferences" ItemName="_UpdatedProjectReferencesInner" />
		</UpdateProjectReferenceVersionsInnerBuild>

		<!-- Replace ProjectReference items with updated versions -->
		<ItemGroup>
			<ProjectReference Remove="@(ProjectReference)" />
			<ProjectReference Include="@(_UpdatedProjectReferencesInner)" />
		</ItemGroup>

		<Message Text="[InnerBuild-SetProjectRefVersions] ProjectReferences AFTER: @(ProjectReference->Count()) items" Importance="High" />
		<Message Text="[InnerBuild-SetProjectRefVersions]   %(ProjectReference.Identity) - Version=%(ProjectReference.Version)" Importance="High" />
		<Message Text="[InnerBuild-SetProjectRefVersions] END" Importance="High" />
	</Target>

	<!-- CRITICAL: Update _ResolvedProjectReferencePaths for NuGet Pack -->
	<!-- NuGet Pack reads from _ResolvedProjectReferencePaths, not ProjectReference -->
	<Target Name="_SetResolvedProjectReferenceVersions"
            AfterTargets="ResolveProjectReferences"
            BeforeTargets="_GetBuildOutputFilesWithTfm;_GetTargetFrameworksOutput;GenerateNuspec"
            Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsTestProject)' != 'true'">

		<Message Text="[InnerBuild-SetResolvedRefVersions] START - Updating _ResolvedProjectReferencePaths for NuGet Pack" Importance="High" />
		<Message Text="[InnerBuild-SetResolvedRefVersions] _ResolvedProjectReferencePaths BEFORE: @(_ResolvedProjectReferencePaths->Count()) items" Importance="High" />
		<Message Text="[InnerBuild-SetResolvedRefVersions]   %(_ResolvedProjectReferencePaths.Identity) - NuGetPackageId=%(_ResolvedProjectReferencePaths.NuGetPackageId), NuGetPackageVersion=%(_ResolvedProjectReferencePaths.NuGetPackageVersion)" Importance="High" />

		<!-- Get versions from all ProjectReference targets -->
		<MSBuild Projects="@(ProjectReference)"
                 Targets="_MonoRepoGetPackageVersion"
                 BuildInParallel="$(BuildInParallel)"
                 Properties="$(MSBuildGlobalProperties)"
                 Condition="'$(MonoRepoVersioningEnabled)'=='true'"
                 ContinueOnError="WarnAndContinue">
			<Output TaskParameter="TargetOutputs" ItemName="_ProjectReferenceVersionsForResolved" />
		</MSBuild>

		<Message Text="[InnerBuild-SetResolvedRefVersions] Resolved versions: %(_ProjectReferenceVersionsForResolved.Identity) = %(_ProjectReferenceVersionsForResolved.Version)" Importance="High" />

		<!-- Update _ResolvedProjectReferencePaths items with correct NuGetPackageVersion -->
		<!-- Match by NuGetPackageId which already exists on these items -->
		<ItemGroup>
			<_ResolvedProjectReferencePaths>
				<NuGetPackageVersion>%(_ProjectReferenceVersionsForResolved->WithMetadataValue('Identity', '%(_ResolvedProjectReferencePaths.NuGetPackageId)')->'%(Version)')</NuGetPackageVersion>
			</_ResolvedProjectReferencePaths>
		</ItemGroup>

		<Message Text="[InnerBuild-SetResolvedRefVersions] _ResolvedProjectReferencePaths AFTER: @(_ResolvedProjectReferencePaths->Count()) items" Importance="High" />
		<Message Text="[InnerBuild-SetResolvedRefVersions]   %(_ResolvedProjectReferencePaths.Identity) - NuGetPackageId=%(_ResolvedProjectReferencePaths.NuGetPackageId), NuGetPackageVersion=%(_ResolvedProjectReferencePaths.NuGetPackageVersion)" Importance="High" />
		<Message Text="[InnerBuild-SetResolvedRefVersions] END" Importance="High" />
	</Target>

	<!-- Target that returns the package version for this project -->
	<!-- This target is called by dependent projects to get our version -->
	<!-- MUST be available even when MonoRepoVersioningEnabled is false to avoid errors -->
	<Target Name="_MonoRepoGetPackageVersion"
            DependsOnTargets="_MonoRepoSetVersion"
            Returns="@(PackageVersionOutput)">

		<PropertyGroup>
			<!-- Ensure we have a version to return, even if versioning is disabled -->
			<_VersionToReturn Condition="'$(FullVersion)' != ''">$(FullVersion)</_VersionToReturn>
			<_VersionToReturn Condition="'$(FullVersion)' == '' and '$(Version)' != ''">$(Version)</_VersionToReturn>
			<_VersionToReturn Condition="'$(_VersionToReturn)' == ''">1.0.0</_VersionToReturn>
		</PropertyGroup>

		<ItemGroup>
			<PackageVersionOutput Include="$(MSBuildProjectName)">
				<Version>$(_VersionToReturn)</Version>
				<ProjectPath>$(MSBuildProjectFullPath)</ProjectPath>
			</PackageVersionOutput>
		</ItemGroup>

		<Message Text="[MRV-GetPackageVersion] Returning version $(_VersionToReturn) for $(MSBuildProjectName) (MonoRepoVersioningEnabled=$(MonoRepoVersioningEnabled))" Importance="High" Condition="'$(MonoRepoDebug)'=='true'" />
	</Target>

	<!-- CRITICAL FIX: Hook into deps.json generation to ensure ProjectReference dependencies get correct versions -->
	<Target Name="_SetProjectReferenceVersionsForDepsJson"
            BeforeTargets="GenerateBuildDependencyFile;_ComputeUserRuntimeAssemblies;ResolvePackageAssets"
            DependsOnTargets="_MonoRepoSetVersion"
            Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsTestProject)' != 'true'">

		<Message Text="[DepsJsonFix] Starting ProjectReference version resolution for deps.json generation" Importance="High" Condition="'$(MonoRepoDebug)'=='true'" />

		<!-- Get versions from all ProjectReference targets -->
		<MSBuild Projects="@(ProjectReference)"
                 Targets="_MonoRepoGetPackageVersion"
                 BuildInParallel="$(BuildInParallel)"
                 Properties="$(MSBuildGlobalProperties)"
                 Condition="'$(MonoRepoVersioningEnabled)'=='true'"
                 ContinueOnError="WarnAndContinue">
			<Output TaskParameter="TargetOutputs" ItemName="_ProjectRefVersionsForDeps" />
		</MSBuild>

		<!-- Update ProjectReference items with version metadata that deps.json generation can use -->
		<ItemGroup>
			<ProjectReference Update="%(Identity)">
				<!-- Set Version metadata that deps.json generation reads -->
				<Version Condition="'%(_ProjectRefVersionsForDeps.Version)' != ''">%(_ProjectRefVersionsForDeps.Version)</Version>
				<PackageVersion Condition="'%(_ProjectRefVersionsForDeps.Version)' != ''">%(_ProjectRefVersionsForDeps.Version)</PackageVersion>
				<ProjectVersion Condition="'%(_ProjectRefVersionsForDeps.Version)' != ''">%(_ProjectRefVersionsForDeps.Version)</ProjectVersion>
				<NuGetVersion Condition="'%(_ProjectRefVersionsForDeps.Version)' != ''">%(_ProjectRefVersionsForDeps.Version)</NuGetVersion>
			</ProjectReference>
		</ItemGroup>

		<Message Text="[DepsJsonFix] Updated ProjectReference versions for deps.json generation: @(_ProjectRefVersionsForDeps)" Importance="High" Condition="'$(MonoRepoDebug)'=='true'" />
	</Target>

	<!-- Enhanced GetTargetPath to provide version metadata for deps.json generation -->
	<Target Name="_EnhancedGetTargetPathForDeps"
            BeforeTargets="GenerateBuildDependencyFile"
            DependsOnTargets="_MonoRepoSetVersion"
            Condition="'$(MonoRepoVersioningEnabled)'=='true' and '$(IsTestProject)' != 'true'">

		<!-- Ensure properties are available for deps.json generation - override only if we have a calculated version -->
		<PropertyGroup Condition="'$(FullVersion)' != ''">
			<PackageVersion>$(FullVersion)</PackageVersion>
			<Version>$(FullVersion)</Version>
			<AssemblyVersion>$(MainVersion)</AssemblyVersion>
			<FileVersion>$(MainVersion)</FileVersion>
			<InformationalVersion>$(FullVersion)</InformationalVersion>
		</PropertyGroup>

		<Message Text="[DepsJsonFix] Enhanced GetTargetPath providing version $(FullVersion) for deps.json" Importance="High" Condition="'$(MonoRepoDebug)'=='true'" />
	</Target>

	<!-- CRITICAL: Fallback to ensure AssemblyVersion is always set for GenerateDepsFile -->
	<Target Name="_EnsureAssemblyVersionForDepsFile"
            BeforeTargets="GenerateBuildDependencyFile">

		<!-- Ensure AssemblyVersion has a value for GenerateDepsFile task -->
		<PropertyGroup>
			<AssemblyVersion Condition="'$(AssemblyVersion)' == ''">1.0.0.0</AssemblyVersion>
			<FileVersion Condition="'$(FileVersion)' == ''">1.0.0.0</FileVersion>
			<Version Condition="'$(Version)' == ''">1.0.0</Version>
		</PropertyGroup>

		<Message Text="[DepsFileFallback] Ensured AssemblyVersion=$(AssemblyVersion) for GenerateDepsFile" Importance="Low" />
	</Target>

</Project>